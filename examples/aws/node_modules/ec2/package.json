{
  "name": "ec2",
  "description": "Amazon AWS minified.",
  "keywords": [
    "aws",
    "ec2",
    "amazon"
  ],
  "version": "0.1.1",
  "author": {
    "name": "Alan Gutierrez"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/amazon",
  "bin": {
    "ec2": "./bin/ec2"
  },
  "dependencies": {
    "node-xml": ">=1.0.0"
  },
  "devDependencies": {
    "proof": "0.0.8"
  },
  "lib": "lib",
  "scripts": {
    "test": "proof t/*/*.t"
  },
  "engines": {
    "node": "> 0.6.0"
  },
  "readme": "# Node EC2 [![Build Status](https://secure.travis-ci.org/bigeasy/node-ec2.png?branch=master)](http://travis-ci.org/bigeasy/node-ec2)\n\nEvented Node.js bindings to the EC2 Query API.\n\n * **Node EC2** is a minimal Node.js API with a pinch of sugar.\n * **Node EC2** creates a signed request from a AWS EC command name a plain old\nJavaScript object of command parameters.\n * **Node EC2** parses the XML response and converts it into JSON.\n * **Node EC2** does **not** define control flow, so use your favorite control flow\nlibrary.\n * **Node EC2** lets Amazon AWS do all the error checking in one place, then\n   returns the errors as an `Error` to a Node.js style callback.\n\nBecause **Node EC2** is such a thin layer over the Amazon AWS EC2 API you can\nuse the [Amazon API\nReference](http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/index.html?query-apis.html)\nto find your way around. Node EC2 calls translate directly to Amazon Query API.\n\n## Synopsis\n\nAn example using\n[RunInstances](http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/index.html?ApiReference-query-RunInstances.html) to launch a 32-bit Fedora 17 instance in Virginia.\n\nOur program reads the AWS secrets from a file named \"~/.aws\" that contains the\nkey and secret as JSON.\n\n```\n{ \"key\": \"EXAMPLE\"\n, \"secret\": \"EXAMPLE\"\n}\n```\n\nOur program launches and instance, then calls `\"DescribeInstances\"` until it is\nready to use. When it's read it prints the TK host name for use with `ssh`.\n\n```javascript\n// Require EC2.\nvar ec2 = require(\"ec2\")\n  , fs = require(\"fs\")\n  , path = require(\"path\")\n  , configuration = path.resolve(process.env.HOME, \".aws\")\n  ;\n\n// Read in the configuration above.\nvar configuration = JSON.parse(fs.readFileSync(configuration, \"utf8\"));\n\n// Create an ec2 function that uses your configuration.\nec2 = ec2(configuration)\n\n// Run an instance and wait for it to become ready.\nec2(\"RunInstances\", {\n  ImageId: \"ami-2d4aa444\", KeyName: \"launch_key\", MinCount: 1, MaxCount: 1\n}, running);\n\n\nvar reservationId, instanceId;\nfunction running (error, response) {\n  if (error) throw error;\n  reservationId = response.reservationId\n  instanceId = response.instancesSet[0].instanceId;\n  describe();\n}\n\nfunction describe () {\n  ec2(\"DescribeInstances\", {}, starting);\n}\n\nfunction starting (error, response) {\n  if (error) throw error;\n  var reservation, instance;\n  reservation = response.reservationSet.filter(function (reservation) {\n    return reservation.reservationId == reservationId;\n  })[0];\n  instance = reservation.instancesSet.filter(function (instance) {\n    return instance.instanceId == instanceId;\n  })[0];\n  if (instance.instanceState.name == \"running\") ready();\n  else setTimeout(describe, 2500);\n}\n\nfunction ready () {\n  console.log(\"Instance created with id: \" + instanceId);\n}\n```\n\nI'm afraid you'll find that working with Amazon AWS is a bit wordy. The XML\ndocuments seem to gravitate toward the longest possible element name that could\npossibly describe the property\n\n## Installing\n\nThe easiest way to install is using npm.\n\n```\nnpm install ec2\n```\n\nYou can also checkout the source code for using `git`. It has only one\ndependency, the wonderful little XML parser `node-xml`.\n\n## Initialization\n\nNode EC2 exports a function you can use to build an EC2 function. You can call\nit directly from `require(\"ec2\")` to build an `ec2` function configured for your\napplication.\n\n```javascript\nvar ec2 = require(\"ec2\")({ key: \"<REDACTED>\", secret: \"<REDACTED>\" });\n\nec2(\"DescribeInstances\", {}, function (error, result) {\n  if (error) throw error;\n  console.log(result)\n});\n```\n\nOptions to the ec2 function are:\n\n * `key` &mdash; Your Amazon AWS key.\n * `secret` &mdash; Your Amazon AWS secret key, which you should always keep\n   secret.\n * `endpoint` &mdash; Either the region identifier or else the fully qualified\n   domain name of the AWS server.\n\nThe region identifiers are one of the following.\n\n * `us-west-2` &mdash; Oregon.\n * `us-west-1` &mdash; California.\n * `us-east-1` &mdash; Virginia.\n * `sa-east-1` &mdash; Sao Paluo.\n * `ap-northeast-1` &mdash; Tokyo.\n * `ap-southeast-1` &mdash; Singapore.\n * `eu-west-1` &mdash; Ireland.\n\nIf you do not specify `endpoint` when you construct your `ec2` function, you can\nspecify it later when you construct your `ec2` function.\n\n## Invocation\n\nInvoke **Node EC2** by passing a command name, command parameters in an object,\nand a callback.\n\n```javascript\nvar ec2 = require(\"ec2\")({ key: \"<REDACTED>\"\n                         , secret: \"<REDACTED>\"\n                         , endpoint: \"us-east-1\"\n                         })\n  , parameters;\n\nparameters =\n{ ImageId: \"ami-2d4aa444\"\n, KeyName: \"launch_key\"\n, MinCount: 1\n, MaxCount: 1\n};\n\nec2(\"RunInstances\", parameters, function (error, result) {\n  if (error) throw error;\n  console.log(result)\n});\n```\n\nYou can override configuration details by passing an options object as the first\nargument to the **Node EC2** function.\n\n```javascript\nvar ec2 = require(\"ec2\")({ key: \"<REDACTED>\"\n                         , secret: \"<REDACTED>\"\n                         , endpoint: \"us-east-1\"\n                         })\n  , parameters;\n\nparameters =\n{ ImageId: \"ami-e269e5d2\"\n, KeyName: \"launch_key\"\n, MinCount: 1\n, MaxCount: 1\n};\n\nec2({ endpoint: \"us-west-2\" }, \"RunInstances\", parameters, function (error, result) {\n  if (error) throw error;\n  console.log(result)\n});\n```\n\nYou can also create a new **Node EC2** function that extends configuration of an\n**Node EC2** function. You can use this to create a base function that holds\nyour credentials, and specific functions for the specific regions.\n\n```javascript\nvar ec2 = require(\"ec2\")({ key: \"<REDACTED>\" , secret: \"<REDACTED>\" })\n  , ec2east = ec2({ endpoint: \"us-east-1\" })\n  , ec2west = ec2({ endpoint: \"us-west-2\" })\n  , parameters\n  ;\n\nparameters =\n{ ImageId: \"ami-e269e5d2\"\n, KeyName: \"launch_key\"\n, MinCount: 1\n, MaxCount: 1\n};\n\nec2east(\"RunInstances\", parameters, function (error, eastern) {\n  if (error) throw error;\n  parameters.ImageId = \"ami-e269e5d2\";\n  ec2west(\"RunInstances\", parameters, function (error, western) {\n    if (error) throw error;\n    console.log(eastern, western);\n  });\n});\n```\n\n## Why So Simple?\n\nAnother implementation might set out to define a library of functions, one for\neach function provided by the AWS EC2 API. This way, you could validate the\ncommand name and parameters before you call.\n\nWe believe that if there's something wrong with your request, you'll find out\nsoon enough. The Amazon AWS server that handles your request will do a bang up\njob of error checking, and it will be able to do all the error checking in one\nplace.\n\nOn the client side, we could validate parameter names, but on the AWS site\nvalidation goes beyond semantics to authorization, service availability, etc.\n\nIf the Amazon AWS EC2 API adds a dozen new features overnight, you don't have to\nwait for a new version of **Node EC2** to use them.\n\nBecause of this, there is a one to one mapping between the Amazon Query API and\nthe actions provided by **Node EC2**. Changes to the Amazon Query API are\navailable immediately to **Node EC2** applications.\n\nYou can learn more about node-ec2 at the node-ec2 GitHub web page and by reading\nthe wiki.\n\n## Command Line Interface\n\n**Node EC2** also comes with a command line interface. The command line\ninterface is very helpful if you want to examine the JSON results of an Amazon\nAWS EC2 API call.\n\nThe `ec2` program will look for a configuration file at `~/.aws` or else use the\nvalue of the `AWS_CONFIG` environment variable as the path to the configuration\nfile. The configuration file is the JSON file used to create a **Node EC2**\nfunction described above. It contains your key, secret key and the service\nendpoint.\n\n```\n$ ec2 DescribeKeyPairs\n{\n  \"requestId\": \"1d42624e-a3c8-4dca-8d42-6ac0a11f4468\",\n  \"keySet\": [\n    {\n      \"keyName\": \"automation_key\",\n      \"keyFingerprint\": \"82:a4:69:ca:89:31:8f:58:75:ae:24:eb:e5:71:78:56:32:09:3a:24\"\n    },\n    {\n      \"keyName\": \"temporary_key\",\n      \"keyFingerprint\": \"c0:14:ff:06:23:dd:52:6a:4d:29:e9:0f:1f:54:13:73:e1:c8:fd:90\"\n    },\n    {\n      \"keyName\": \"launch_key\",\n      \"keyFingerprint\": \"8c:cf:71:0d:84:05:19:cd:7d:89:ca:62:7e:8f:51:0b:16:df:f4:c0\"\n    }\n  ]\n}\n```\n\nInvocation is first the command name, then command arguments just as they appear\nin the Amazon AWS API. Note that some arguments in the API require a number\nappended to the argument name.\n\n```\n$ ec2 RunInstances ImageId ami-08d97e61 KeyName launch_key MinCount 1 MaxCount 1\n{\n  \"requestId\": \"7aa586a5-c658-4735-9152-72ad20cb3282\",\n  \"reservationId\": \"r-de7200bb\",\n  \"ownerId\": \"341264201128\",\n  \"groupSet\": [\n    {\n      \"groupId\": \"sg-c8f72da7\",\n      \"groupName\": \"default\"\n    }\n  ],\n  \"instancesSet\": [\n    {\n      \"instanceId\": \"i-2af0e253\",\n      \"imageId\": \"ami-08d97e61\",\n      \"instanceState\": {\n        \"code\": \"0\",\n        \"name\": \"pending\"\n      },\n      \"privateDnsName\": null,\n      \"dnsName\": null,\n      \"reason\": null,\n      \"keyName\": \"launch_key\",\n      \"amiLaunchIndex\": \"0\",\n      \"productCodes\": null,\n      \"instanceType\": \"m1.small\",\n      \"launchTime\": \"2012-06-28T18:29:55.000Z\",\n      \"placement\": {\n        \"availabilityZone\": \"us-east-1a\",\n        \"groupName\": null,\n        \"tenancy\": \"default\"\n      },\n      \"kernelId\": \"aki-407d9529\",\n      \"monitoring\": {\n        \"state\": \"disabled\"\n      },\n      \"groupSet\": [\n        {\n          \"groupId\": \"sg-c8f72da7\",\n          \"groupName\": \"default\"\n        }\n      ],\n      \"stateReason\": {\n        \"code\": \"pending\",\n        \"message\": \"pending\"\n      },\n      \"architecture\": \"i386\",\n      \"rootDeviceType\": \"ebs\",\n      \"rootDeviceName\": \"/dev/sda1\",\n      \"blockDeviceMapping\": null,\n      \"virtualizationType\": \"paravirtual\",\n      \"clientToken\": null,\n      \"hypervisor\": \"xen\"\n    }\n  ]\n}\n```\n\n## Change Log\n\nChanges for each release since 0.1.1.\n\n### Version 0.1.1 &mdash; Thu Jun 28 22:08:28 UTC 2012\n\n * Publish a version without junk directories that defeat NPM. #9. #23.\n * Create change log. #13.\n * Specify fully qualified hostname for endpoint. #25. #3\n * Rewrite `README.md` to describe one function API.\n * Delete `Cakefile`. #16.\n * Convert to JavaScript. #10.\n\nVersions prior to 0.1.1 were not tracked very well in `git`. My fault, but I'm\nnot feeling the guilt necessary to perform the `git` forensics necessary to\nreconstruct a change log.\n",
  "_id": "ec2@0.1.1",
  "_from": "ec2@*"
}
